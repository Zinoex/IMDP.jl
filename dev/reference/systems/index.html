<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Systems · IntervalMDP.jl</title><meta name="title" content="Systems · IntervalMDP.jl"/><meta property="og:title" content="Systems · IntervalMDP.jl"/><meta property="twitter:title" content="Systems · IntervalMDP.jl"/><meta name="description" content="Documentation for IntervalMDP.jl."/><meta property="og:description" content="Documentation for IntervalMDP.jl."/><meta property="twitter:description" content="Documentation for IntervalMDP.jl."/><meta property="og:url" content="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><meta property="twitter:url" content="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><link rel="canonical" href="https://www.baymler.com/IntervalMDP.jl/reference/systems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="IntervalMDP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalMDP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><a class="tocitem" href="../../data/">Data formats</a></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../algorithms/">Algorithms</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Systems</a><ul class="internal"><li><a class="tocitem" href="#Probability-representation"><span>Probability representation</span></a></li></ul></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../value_iteration/">Value Iteration</a></li><li><a class="tocitem" href="../data/">Data Storage</a></li></ul></li><li><a class="tocitem" href="../../api/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Zinoex/IntervalMDP.jl/blob/main/docs/src/reference/systems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="System-representation"><a class="docs-heading-anchor" href="#System-representation">System representation</a><a id="System-representation-1"></a><a class="docs-heading-anchor-permalink" href="#System-representation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.IntervalMarkovProcess" href="#IntervalMDP.IntervalMarkovProcess"><code>IntervalMDP.IntervalMarkovProcess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalMarkovProcess</code></pre><p>An abstract type for interval Markov processes including <a href="#IntervalMDP.IntervalMarkovChain"><code>IntervalMarkovChain</code></a> and <a href="#IntervalMDP.IntervalMarkovDecisionProcess"><code>IntervalMarkovDecisionProcess</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovProcess.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.num_states-Tuple{IntervalMarkovProcess}" href="#IntervalMDP.num_states-Tuple{IntervalMarkovProcess}"><code>IntervalMDP.num_states</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_states(mp::IntervalMarkovProcess)</code></pre><p>Return the number of states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovProcess.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.initial_states-Tuple{IntervalMarkovProcess}" href="#IntervalMDP.initial_states-Tuple{IntervalMarkovProcess}"><code>IntervalMDP.initial_states</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initial_states(mp::IntervalMarkovProcess)</code></pre><p>Return the initial states. If the initial states are not specified, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovProcess.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.AllStates" href="#IntervalMDP.AllStates"><code>IntervalMDP.AllStates</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllStates</code></pre><p>A type to represent all states in a Markov process. This type is used to specify all states as the initial states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovProcess.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.transition_prob-Tuple{IntervalMarkovProcess}" href="#IntervalMDP.transition_prob-Tuple{IntervalMarkovProcess}"><code>IntervalMDP.transition_prob</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transition_prob(mp::IntervalMarkovProcess)</code></pre><p>Return the interval on transition probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovProcess.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.IntervalMarkovChain" href="#IntervalMDP.IntervalMarkovChain"><code>IntervalMDP.IntervalMarkovChain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalMarkovChain(transition_prob::IntervalProbabilities, initial_states::InitialStates = AllStates())</code></pre><p>Construct an Interval Markov Chain from a square matrix pair of interval transition probabilities. The initial states are optional and if not specified, all states are assumed to be initial states. The number of states is inferred from the size of the transition probability matrix.</p><p>The returned type is an <code>IntervalMarkovDecisionProcess</code> with only one action per state (i.e. <code>stateptr[j + 1] - stateptr[j] == 1</code> for all <code>j</code>). This is done to unify the interface for value iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovDecisionProcess.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.IntervalMarkovDecisionProcess" href="#IntervalMDP.IntervalMarkovDecisionProcess"><code>IntervalMDP.IntervalMarkovDecisionProcess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalMarkovDecisionProcess{
    P &lt;: IntervalProbabilities,
    VT &lt;: AbstractVector{Int32},
    VI &lt;: Union{AllStates, AbstractVector}
}</code></pre><p>A type representing (stationary) Interval Markov Decision Processes (IMDP), which are Markov Decision Processes with uncertainty in the form of intervals on the transition probabilities.</p><p>Formally, let <span>$(S, S_0, A, \bar{P}, \underbar{P})$</span> be an interval Markov decision processes, where <span>$S$</span> is the set of states, <span>$S_0 \subset S$</span> is the set of initial states, <span>$A$</span> is the set of actions, and <span>$\bar{P} : A \to \mathbb{R}^{|S| \times |S|}$</span> and <span>$\underbar{P} : A \to \mathbb{R}^{|S| \times |S|}$</span> are functions representing the upper and lower bound transition probability matrices prespectively for each action. Then the <code>IntervalMarkovDecisionProcess</code> type is defined as follows: indices <code>1:num_states</code> are the states in <span>$S$</span>, <code>transition_prob</code> represents <span>$\bar{P}$</span> and <span>$\underbar{P}$</span>, actions are  implicitly defined by <code>stateptr</code> (e.g. if <code>stateptr[3] == 4</code> and <code>stateptr[4] == 7</code> then the actions available to state 3 are <code>[4, 5, 6]</code>),  and <code>initial_states</code> is the set of initial states <span>$S_0$</span>. If no initial states are specified, then the initial states are assumed to be all states in <span>$S$</span>.</p><p><strong>Fields</strong></p><ul><li><code>transition_prob::P</code>: interval on transition probabilities where columns represent source/action pairs and rows represent target states.</li><li><code>stateptr::VT</code>: pointer to the start of each source state in <code>transition_prob</code> (i.e. <code>transition_prob[:, stateptr[j]:stateptr[j + 1] - 1]</code> is the transition   probability matrix for source state <code>j</code>) in the style of colptr for sparse matrices in CSC format.</li><li><code>initial_states::VI</code>: initial states.</li><li><code>num_states::Int32</code>: number of states.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">transition_probs = IntervalProbabilities(;
    lower = [
        0.0 0.5 0.1 0.2 0.0
        0.1 0.3 0.2 0.3 0.0
        0.2 0.1 0.3 0.4 1.0
    ],
    upper = [
        0.5 0.7 0.6 0.6 0.0
        0.6 0.5 0.5 0.5 0.0
        0.7 0.3 0.4 0.4 1.0
    ],
)

stateptr = [1, 3, 5, 6]
initial_states = [1]

mdp = IntervalMarkovDecisionProcess(transition_probs, stateptr, initial_states)</code></pre><p>There is also a constructor for <code>IntervalMarkovDecisionProcess</code> where the transition probabilities are given as a list of  transition probabilities for each source state.</p><pre><code class="language-julia hljs">prob1 = IntervalProbabilities(;
    lower = [
        0.0 0.5
        0.1 0.3
        0.2 0.1
    ],
    upper = [
        0.5 0.7
        0.6 0.5
        0.7 0.3
    ],
)

prob2 = IntervalProbabilities(;
    lower = [
        0.1 0.2
        0.2 0.3
        0.3 0.4
    ],
    upper = [
        0.6 0.6
        0.5 0.5
        0.4 0.4
    ],
)

prob3 = IntervalProbabilities(;
    lower = [0.0; 0.0; 1.0],
    upper = [0.0; 0.0; 1.0]
)

transition_probs = [prob1, prob2, prob3]
initial_states = [1]

mdp = IntervalMarkovDecisionProcess(transition_probs, initial_states)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovDecisionProcess.jl#L1-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.stateptr-Tuple{IntervalMarkovDecisionProcess}" href="#IntervalMDP.stateptr-Tuple{IntervalMarkovDecisionProcess}"><code>IntervalMDP.stateptr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stateptr(mdp::IntervalMarkovDecisionProcess)</code></pre><p>Return the state pointer of the Interval Markov Decision Process. The state pointer is a vector of integers where the <code>i</code>-th element is the index of the first element of the <code>i</code>-th state in the transition probability matrix.  I.e. <code>transition_prob[:, stateptr[j]:stateptr[j + 1] - 1]</code> is the transition probability matrix for source state <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/IntervalMarkovDecisionProcess.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.OrthogonalIntervalMarkovChain" href="#IntervalMDP.OrthogonalIntervalMarkovChain"><code>IntervalMDP.OrthogonalIntervalMarkovChain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrthogonalIntervalMarkovChain(transition_prob::OrthogonalIntervalProbabilities, initial_states::InitialStates = AllStates())</code></pre><p>Construct a Orthogonal Interval Markov Chain from orthogonal interval transition probabilities. The initial states are optional and if not specified, all states are assumed to be initial states. The number of states is inferred from the size of the transition probability matrix.</p><p>The returned type is an <code>OrthogonalIntervalMarkovDecisionProcess</code> with only one action per state (i.e. <code>stateptr[j + 1] - stateptr[j] == 1</code> for all <code>j</code>). This is done to unify the interface for value iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/OrthogonalIntervalMarkovDecisionProcess.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.OrthogonalIntervalMarkovDecisionProcess" href="#IntervalMDP.OrthogonalIntervalMarkovDecisionProcess"><code>IntervalMDP.OrthogonalIntervalMarkovDecisionProcess</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrthogonaIntervalMarkovDecisionProcess{
    P &lt;: IntervalProbabilities,
    VT &lt;: AbstractVector{Int32},
    VI &lt;: Union{AllStates, AbstractVector}
}</code></pre><p>A type representing (stationary) Orthogona Interval Markov Decision Processes (OIMDP), which are IMDPs where the transition  probabilities for each state can be represented as the product of the transition probabilities of individual processes.</p><p><strong>TODO: Update theory section</strong></p><p>Formally, let <span>$(S, S_0, A, \bar{P}, \underbar{P})$</span> be an interval Markov decision processes, where <span>$S$</span> is the set of states, <span>$S_0 \subset S$</span> is the set of initial states, <span>$A$</span> is the set of actions, and <span>$\bar{P} : A \to \mathbb{R}^{|S| \times |S|}$</span> and <span>$\underbar{P} : A \to \mathbb{R}^{|S| \times |S|}$</span> are functions representing the upper and lower bound transition probability matrices prespectively for each action. Then the <code>IntervalMarkovDecisionProcess</code> type is defined as follows: indices <code>1:num_states</code> are the states in <span>$S$</span>, <code>transition_prob</code> represents <span>$\bar{P}$</span> and <span>$\underbar{P}$</span>, actions are  implicitly defined by <code>stateptr</code> (e.g. if <code>stateptr[3] == 4</code> and <code>stateptr[4] == 7</code> then the actions available to state 3 are <code>[4, 5, 6]</code>),  and <code>initial_states</code> is the set of initial states <span>$S_0$</span>. If no initial states are specified, then the initial states are assumed to be all states in <span>$S$</span>.</p><p><strong>Fields</strong></p><p><strong>TODO: Update fields</strong></p><ul><li><code>transition_prob::P</code>: interval on transition probabilities where columns represent source/action pairs and rows represent target states.</li><li><code>stateptr::VT</code>: pointer to the start of each source state in <code>transition_prob</code> (i.e. <code>transition_prob[:, stateptr[j]:stateptr[j + 1] - 1]</code> is the transition   probability matrix for source state <code>j</code>) in the style of colptr for sparse matrices in CSC format.</li><li><code>initial_states::VI</code>: initial states.</li><li><code>num_states::Int32</code>: number of states.</li></ul><p><strong>Examples</strong></p><p><strong>TODO: Update examples</strong></p><pre><code class="language-julia hljs">transition_probs = IntervalProbabilities(;
    lower = [
        0.0 0.5 0.1 0.2 0.0
        0.1 0.3 0.2 0.3 0.0
        0.2 0.1 0.3 0.4 1.0
    ],
    upper = [
        0.5 0.7 0.6 0.6 0.0
        0.6 0.5 0.5 0.5 0.0
        0.7 0.3 0.4 0.4 1.0
    ],
)

stateptr = [1, 3, 5, 6]
initial_states = [1]

mdp = IntervalMarkovDecisionProcess(transition_probs, stateptr, initial_states)</code></pre><p>There is also a constructor for <code>IntervalMarkovDecisionProcess</code> where the transition probabilities are given as a list of  transition probabilities for each source state.</p><pre><code class="language-julia hljs">prob1 = IntervalProbabilities(;
    lower = [
        0.0 0.5
        0.1 0.3
        0.2 0.1
    ],
    upper = [
        0.5 0.7
        0.6 0.5
        0.7 0.3
    ],
)

prob2 = IntervalProbabilities(;
    lower = [
        0.1 0.2
        0.2 0.3
        0.3 0.4
    ],
    upper = [
        0.6 0.6
        0.5 0.5
        0.4 0.4
    ],
)

prob3 = IntervalProbabilities(;
    lower = [0.0; 0.0; 1.0],
    upper = [0.0; 0.0; 1.0]
)

transition_probs = [prob1, prob2, prob3]
initial_states = [1]

mdp = IntervalMarkovDecisionProcess(transition_probs, initial_states)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/OrthogonalIntervalMarkovDecisionProcess.jl#L1-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.stateptr-Tuple{OrthogonalIntervalMarkovDecisionProcess}" href="#IntervalMDP.stateptr-Tuple{OrthogonalIntervalMarkovDecisionProcess}"><code>IntervalMDP.stateptr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stateptr(mdp::OrthogonalIntervalMarkovDecisionProcess)</code></pre><p>Return the state pointer of the Interval Markov Decision Process. The state pointer is a vector of integers where the <code>i</code>-th element is the index of the first element of the <code>i</code>-th state in the transition probability matrix.  I.e. <code>transition_prob[:, stateptr[j]:stateptr[j + 1] - 1]</code> is the transition probability matrix for source state <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/models/OrthogonalIntervalMarkovDecisionProcess.jl#L178-L184">source</a></section></article><h2 id="Probability-representation"><a class="docs-heading-anchor" href="#Probability-representation">Probability representation</a><a id="Probability-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-representation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.IntervalProbabilities" href="#IntervalMDP.IntervalProbabilities"><code>IntervalMDP.IntervalProbabilities</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalProbabilities{R, VR &lt;: AbstractVector{R}, MR &lt;: AbstractMatrix{R}}</code></pre><p>A matrix pair to represent the lower and upper bound transition probabilities from all source states or source/action pairs to all target states. The matrices can be <code>Matrix{R}</code> or <code>SparseMatrixCSC{R}</code>, or their CUDA equivalents. For memory efficiency, it is recommended to use sparse matrices.</p><p>The columns represent the source and the rows represent the target, as if the probability matrix was a linear transformation. Mathematically, let <span>$P$</span> be the probability matrix. Then <span>$P_{ij}$</span> represents the probability of transitioning from state <span>$j$</span> (or with state/action pair <span>$j$</span>) to state <span>$i$</span>. Due to the column-major format of Julia, this is also a more efficient representation (in terms of cache locality).</p><p>The lower bound is explicitly stored, while the upper bound is computed from the lower bound and the gap. This choice is  because it simplifies repeated probability assignment using O-maximization [1].</p><p><strong>Fields</strong></p><ul><li><code>lower::MR</code>: The lower bound transition probabilities from a source state or source/action pair to a target state.</li><li><code>gap::MR</code>: The gap between upper and lower bound transition probabilities from a source state or source/action pair to a target state.</li><li><code>sum_lower::VR</code>: The sum of lower bound transition probabilities from a source state or source/action pair to all target states.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">dense_prob = IntervalProbabilities(;
    lower = [0.0 0.5; 0.1 0.3; 0.2 0.1],
    upper = [0.5 0.7; 0.6 0.5; 0.7 0.3],
)

sparse_prob = IntervalProbabilities(;
    lower = sparse_hcat(
        SparseVector(15, [4, 10], [0.1, 0.2]),
        SparseVector(15, [5, 6, 7], [0.5, 0.3, 0.1]),
    ),
    upper = sparse_hcat(
        SparseVector(15, [1, 4, 10], [0.5, 0.6, 0.7]),
        SparseVector(15, [5, 6, 7], [0.7, 0.5, 0.3]),
    ),
)</code></pre><p>[1] M. Lahijanian, S. B. Andersson and C. Belta, &quot;Formal Verification and Synthesis for Discrete-Time Stochastic Systems,&quot; in IEEE Transactions on Automatic Control, vol. 60, no. 8, pp. 2031-2045, Aug. 2015, doi: 10.1109/TAC.2015.2398883.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.OrthogonalIntervalProbabilities" href="#IntervalMDP.OrthogonalIntervalProbabilities"><code>IntervalMDP.OrthogonalIntervalProbabilities</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrthogonalIntervalProbabilities{N, P &lt;: IntervalProbabilities}</code></pre><p>A tuple of <code>IntervalProbabilities</code> transition probabilities from all source states or source/action pairs to the target states along each axis. </p><p><strong>Fields</strong></p><ul><li><code>probs::NTuple{N, P}</code>: A tuple of <code>IntervalProbabilities</code> transition probabilities along each axis.</li><li><code>source_dims::NTuple{N, Int32}</code>: The dimensions of the orthogonal probabilities for the source axis. This is flattened to a single dimension for indexing.</li></ul><p><strong>Examples</strong></p><p><strong>TODO: Update example</strong></p><p>```jldoctest</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L216-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.lower" href="#IntervalMDP.lower"><code>IntervalMDP.lower</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lower(p::IntervalProbabilities)</code></pre><p>Return the lower bound transition probabilities from a source state or source/action pair to a target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L130-L134">source</a></section><section><div><pre><code class="language-julia hljs">lower(p::OrthogonalIntervalProbabilities, i)</code></pre><p>Return the lower bound transition probabilities from a source state or source/action pair to a target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.upper" href="#IntervalMDP.upper"><code>IntervalMDP.upper</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">upper(p::IntervalProbabilities)</code></pre><p>Return the upper bound transition probabilities from a source state or source/action pair to a target state.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not recommended to use this function for the hot loop of O-maximization. Because the <a href="#IntervalMDP.IntervalProbabilities"><code>IntervalProbabilities</code></a> stores the lower and gap transition probabilities, fetching the upper bound requires allocation and computation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L137-L145">source</a></section><section><div><pre><code class="language-julia hljs">upper(p::OrthogonalIntervalProbabilities, i)</code></pre><p>Return the upper bound transition probabilities from a source state or source/action pair to a target state.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not recommended to use this function for the hot loop of O-maximization. Because the <a href="#IntervalMDP.IntervalProbabilities"><code>IntervalProbabilities</code></a> stores the lower and gap transition probabilities, fetching the upper bound requires allocation and computation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L243-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.gap" href="#IntervalMDP.gap"><code>IntervalMDP.gap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gap(p::IntervalProbabilities)</code></pre><p>Return the gap between upper and lower bound transition probabilities from a source state or source/action pair to a target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L148-L152">source</a></section><section><div><pre><code class="language-julia hljs">gap(p::OrthogonalIntervalProbabilities, i)</code></pre><p>Return the gap between upper and lower bound transition probabilities from a source state or source/action pair to a target state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.sum_lower" href="#IntervalMDP.sum_lower"><code>IntervalMDP.sum_lower</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum_lower(p::IntervalProbabilities)</code></pre><p>Return the sum of lower bound transition probabilities from a source state or source/action pair to all target states. This is useful in efficiently implementing O-maximization, where we start with a lower bound probability assignment and iteratively, according to the ordering, adding the gap until the sum of probabilities is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L155-L161">source</a></section><section><div><pre><code class="language-julia hljs">sum_lower(p::OrthogonalIntervalProbabilities, i)</code></pre><p>Return the sum of lower bound transition probabilities from a source state or source/action pair to all target states. This is useful in efficiently implementing O-maximization, where we start with a lower bound probability assignment and iteratively, according to the ordering, adding the gap until the sum of probabilities is 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.num_source" href="#IntervalMDP.num_source"><code>IntervalMDP.num_source</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_source(p::IntervalProbabilities)</code></pre><p>Return the number of source states or source/action pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L164-L168">source</a></section><section><div><pre><code class="language-julia hljs">num_source(p::OrthogonalIntervalProbabilities)</code></pre><p>Return the number of source states or source/action pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.num_target" href="#IntervalMDP.num_target"><code>IntervalMDP.num_target</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_target(p::IntervalProbabilities)</code></pre><p>Return the number of target states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMDP.axes_source" href="#IntervalMDP.axes_source"><code>IntervalMDP.axes_source</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axes_source(p::IntervalProbabilities)</code></pre><p>Return the valid range of indices for the source states or source/action pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L172-L176">source</a></section><section><div><pre><code class="language-julia hljs">axes_source(p::OrthogonalIntervalProbabilities)</code></pre><p>Return the valid range of indices for the source states or source/action pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zinoex/IntervalMDP.jl/blob/a65eaff8504d9cc63074c616086cf8c99defa829/src/interval_probabilities.jl#L278-L282">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../algorithms/">« Algorithms</a><a class="docs-footer-nextpage" href="../specifications/">Specifications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 15 October 2024 08:00">Tuesday 15 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
